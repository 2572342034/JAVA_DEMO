/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */let W;const k=e=>W=e,O=Symbol();function x(e){return e&&typeof e=="object"&&Object.prototype.toString.call(e)==="[object Object]"&&typeof e.toJSON!="function"}var g;(function(e){e.direct="direct",e.patchObject="patch object",e.patchFunction="patch function"})(g||(g={}));function G(){const e=VueDemi.effectScope(!0),c=e.run(()=>VueDemi.ref({}));let s=[],t=[];const o=VueDemi.markRaw({install(r){k(o),VueDemi.isVue2||(o._a=r,r.provide(O,o),r.config.globalProperties.$pinia=o,t.forEach(f=>s.push(f)),t=[])},use(r){return!this._a&&!VueDemi.isVue2?t.push(r):s.push(r),this},_p:s,_a:null,_e:e,_s:new Map,state:c});return o}const F=()=>{};function L(e,c,s,t=F){e.push(c);const o=()=>{const r=e.indexOf(c);r>-1&&(e.splice(r,1),t())};return!s&&VueDemi.getCurrentScope()&&VueDemi.onScopeDispose(o),o}function d(e,...c){e.slice().forEach(s=>{s(...c)})}const z=e=>e();function C(e,c){e instanceof Map&&c instanceof Map&&c.forEach((s,t)=>e.set(t,s)),e instanceof Set&&c instanceof Set&&c.forEach(e.add,e);for(const s in c){if(!c.hasOwnProperty(s))continue;const t=c[s],o=e[s];x(o)&&x(t)&&e.hasOwnProperty(s)&&!VueDemi.isRef(t)&&!VueDemi.isReactive(t)?e[s]=C(o,t):e[s]=t}return e}const K=Symbol(),Q=new WeakMap;function U(e){return VueDemi.isVue2?!Q.has(e):!x(e)||!e.hasOwnProperty(K)}const{assign:D}=Object;function X(e){return!!(VueDemi.isRef(e)&&e.effect)}function Y(e,c,s,t){const{state:o,actions:r,getters:f}=c,i=s.state.value[e];let j;function V(){i||(VueDemi.isVue2?VueDemi.set(s.state.value,e,o?o():{}):s.state.value[e]=o?o():{});const v=VueDemi.toRefs(s.state.value[e]);return D(v,r,Object.keys(f||{}).reduce((S,_)=>(S[_]=VueDemi.markRaw(VueDemi.computed(()=>{k(s);const b=s._s.get(e);if(!(VueDemi.isVue2&&!b._r))return f[_].call(b,b)})),S),{}))}return j=H(e,V,c,s,t,!0),j}function H(e,c,s={},t,o,r){let f;const i=D({actions:{}},s),j={deep:!0};let V,v,S=[],_=[],b;const R=t.state.value[e];!r&&!R&&(VueDemi.isVue2?VueDemi.set(t.state.value,e,{}):t.state.value[e]={}),VueDemi.ref({});let E;function p(n){let u;V=v=!1,typeof n=="function"?(n(t.state.value[e]),u={type:g.patchFunction,storeId:e,events:b}):(C(t.state.value[e],n),u={type:g.patchObject,payload:n,storeId:e,events:b});const m=E=Symbol();VueDemi.nextTick().then(()=>{E===m&&(V=!0)}),v=!0,d(S,u,t.state.value[e])}const M=r?function(){const{state:u}=s,m=u?u():{};this.$patch(y=>{D(y,m)})}:F;function B(){f.stop(),S=[],_=[],t._s.delete(e)}function J(n,u){return function(){k(t);const m=Array.from(arguments),y=[],w=[];function N(l){y.push(l)}function q(l){w.push(l)}d(_,{args:m,name:n,store:a,after:N,onError:q});let P;try{P=u.apply(this&&this.$id===e?this:a,m)}catch(l){throw d(w,l),l}return P instanceof Promise?P.then(l=>(d(y,l),l)).catch(l=>(d(w,l),Promise.reject(l))):(d(y,P),P)}}const I={_p:t,$id:e,$onAction:L.bind(null,_),$patch:p,$reset:M,$subscribe(n,u={}){const m=L(S,n,u.detached,()=>y()),y=f.run(()=>VueDemi.watch(()=>t.state.value[e],w=>{(u.flush==="sync"?v:V)&&n({storeId:e,type:g.direct,events:b},w)},D({},j,u)));return m},$dispose:B};VueDemi.isVue2&&(I._r=!1);const a=VueDemi.reactive(I);t._s.set(e,a);const h=(t._a&&t._a.runWithContext||z)(()=>t._e.run(()=>(f=VueDemi.effectScope()).run(c)));for(const n in h){const u=h[n];if(VueDemi.isRef(u)&&!X(u)||VueDemi.isReactive(u))r||(R&&U(u)&&(VueDemi.isRef(u)?u.value=R[n]:C(u,R[n])),VueDemi.isVue2?VueDemi.set(t.state.value[e],n,u):t.state.value[e][n]=u);else if(typeof u=="function"){const m=J(n,u);VueDemi.isVue2?VueDemi.set(h,n,m):h[n]=m,i.actions[n]=u}}return VueDemi.isVue2?Object.keys(h).forEach(n=>{VueDemi.set(a,n,h[n])}):(D(a,h),D(VueDemi.toRaw(a),h)),Object.defineProperty(a,"$state",{get:()=>t.state.value[e],set:n=>{p(u=>{D(u,n)})}}),VueDemi.isVue2&&(a._r=!0),t._p.forEach(n=>{D(a,f.run(()=>n({store:a,app:t._a,pinia:t,options:i})))}),R&&r&&s.hydrate&&s.hydrate(a.$state,R),V=!0,v=!0,a}function A(e,c,s){let t,o;const r=typeof c=="function";typeof e=="string"?(t=e,o=r?s:c):(o=e,t=e.id);function f(i,j){const V=VueDemi.hasInjectionContext();return i=i||(V?VueDemi.inject(O,null):null),i&&k(i),i=W,i._s.has(t)||(r?H(t,c,o,i):Y(t,o,i)),i._s.get(t)}return f.$id=t,f}function $(e){if(VueDemi.isVue2)return VueDemi.toRefs(e);{e=VueDemi.toRaw(e);const c={};for(const s in e){const t=e[s];(VueDemi.isRef(t)||VueDemi.isReactive(t))&&(c[s]=VueDemi.toRef(e,s))}return c}}export{G as c,A as d,$ as s};
